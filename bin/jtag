#!/usr/bin/env ruby
# encoding: utf-8
require "gli"
require "jtag"
require "fcntl"

include GLI::App

program_desc "Autotagging for Jekyll"

version Jtag::VERSION

@piped_content = nil

##
## Define global flags and switches
##
desc "Expect input from STDIN to be null (0)-delimited: Useful for piping file lists from `find` or `grep`"
default_value false
switch %i[0 null], negatable: false

desc "Path to alternate configuration directory"
arg_name "config_dir"
flag %i[c config_dir], :type => String

desc "Debug level: Set the debug level for the application. 0 is silent, 1 is errors only, 2 is errors and warnings, 3 is errors, warnings and info"
arg_name "debug_level"
flag %i[d debug], :must_match => /\d+/, :type => Integer, :default_value => 3

desc "Perform case-insensitive matches and searches: Useful for case-insensitive filesystems or when you're not sure of the case of your tags"
switch %i[i case_insensitive], negatable: false

desc "Run silently: Suppress all output to STDOUT, same as debug level 0"
switch %i[s silent], negatable: false

desc "Test (dry run, don't update files): Run all commands and show results on the command line, but don't overwrite/update any files"
default_value false
switch %i[t test], negatable: false

# Add a command to update and notify the user of the configuration files location
desc "Update and notify user of configuration files location"
command :config do |c|
  # Add a switch to reset all configuration files to default values
  c.desc "Reset all configuration files to default values"
  c.switch %i[r reset]

  c.desc "Set a specific configuration value"
  c.arg_name "key"
  c.flag %i[s set]

  c.desc "The value to set for key"
  c.arg_name "value"
  c.flag %i[v value]

  # Skip the pre block for this command
  c.skips_pre

  # Define the action to be taken when the command is executed
  c.action do |global_options, options, args|
    if options[:set]
      config = YAML.load_file(File.join(@util.config_target, "config.yml"))
      config[options[:set]] = options[:value]
      File.open(File.join(@util.config_target, "config.yml"), "w") do |f|
        f.write(config.to_yaml)
      end
      return
    end

    if options[:r]
      # Prompt the user for confirmation before resetting config files
      print "Are you sure you want to reset all config files? y/N: "
      response = STDIN.gets.strip
      if response =~ /^y/i
        # Reset config files to default values
        @util.write_config(true)
        @util.console_log "Config files reset"
      end
    else
      # Update config files without overwriting existing files
      @util.write_config(false)
    end
  end
end

desc "List tags, optionally filter for keywords/regular expressions (OR)"
long_desc "This command can be used to find the exact format for a given tag to keep spaces, underscores, capitalization and pluralization consistent"
arg_name "keyword", :multiple
command :search do |c|
  c.desc "Format to use when outputting tags to console: list, json, plist, csv or yaml. Defaults to yaml."
  c.arg_name "output_format"
  c.default_value "yaml"
  c.flag %i[f format], :must_match => /^(csv|list|yaml|json|plist)$/i, :type => String

  c.desc "Include tag counts"
  c.arg_name "counts"
  c.default_value false
  c.switch %i[c counts]

  c.desc "Boolean operator for multiple tags (AND/OR/NOT)"
  c.arg_name "bool"
  c.default_value "OR"
  c.flag %i[b bool], :must_match => /^([aon])(?:.*)$/i, :type => String

  c.desc "Match type: exact, fuzzy, starts_with, contains"
  c.arg_name "match_type"
  c.default_value "contains"
  c.flag %i[m match], :must_match => /^([exfsc])(?:.*)$/i, :type => String

  c.desc "Case-sensitive matching"
  c.switch %i[I s case_sensitive], negatable: true

  c.desc "Fuzzy match distance"
  c.arg_name "distance"
  c.default_value 2
  c.flag %i[d distance], :must_match => /^\d+$/, :type => Integer

  c.action do |global_options, options, args|
    # Initialize arrays to store files and keywords
    files = []
    keywords = []
    bool_op = options[:bool].to_bool

    # Iterate over the arguments and separate files from keywords
    args.length.times do
      arg = args.pop
      if File.file?(File.expand_path(arg))
        files.push(File.expand_path(arg))  # Add existing files to the files array
      else
        keywords.push(arg)  # Add non-file arguments to the keywords array
      end
    end

    # If piped content is provided and it is a list of files, add them to the files array
    files.concat(@piped_content.split(global_options[:null] ? "\x00" : "\n")) if @piped_content && @piped_content.file_list?(global_options[:null])

    # If no files are provided, use the default post location
    if files.empty?
      if @jt.default_post_location && File.exist?(@jt.default_post_location)
        # Retrieves a list of files from the default post location with the specified post extension.
        # The files are located using a glob pattern that matches all files with the given extension.
        #
        # @return [Array<String>] an array of file paths matching the specified pattern
        files = Dir.glob(File.join(@jt.default_post_location, "*.#{@jt.post_extension}"))
      end
    end

    tags = {}

    # Get tags with counts for the specified files
    if @piped_content && !@piped_content.file_list?(global_options[:null])
      if @piped_content.yaml?
        tags = YAML.load(@piped_content).to_counts
      elsif @piped_content.json?
        tags = JSON.parse(@piped_content).to_counts
      elsif @piped_content.tag_list?
        tags = @piped_content.split("\n").map(&:strip).to_counts
      else
        tags = @jt.tags({ :counts => true, :files => files })
      end
    else
      tags = @jt.tags({ :counts => true, :files => files })
    end

    raise NoTagsFound, "No source tag list found" if tags.nil? || tags.empty?

    match_options = {
      exact: false,
      contains: false,
      starts_with: false,
      fuzzy: false,
      case_sensitive: options[:case_sensitive],
      distance: options[:distance],
    }

    if options[:match] =~ /^[ex]/i
      match_options[:exact] = true
    elsif options[:match] =~ /^s/i
      match_options[:starts_with] = true
    elsif options[:match] =~ /^f/i
      match_options[:fuzzy] = true
    else
      match_options[:contains] = true
    end

    # If keywords are provided, filter tags based on the keywords
    if keywords.length > 0
      if bool_op == :and
        tags.delete_if { |tag| tag && !keywords.all? { |keyword| tag["name"].match_keyword(keyword, match_options) } }
      elsif bool_op == :not
        re = keywords.join("|")  # Join keywords with OR operator
        # Remove tags that match the keywords
        tags.delete_if { |tag| tag && keywords.any? { |keyword| tag["name"].match_keyword(keyword, match_options) } }
      else
        # :or
        # Filter tags based on any keywords
        tags.delete_if { |tag| tag && !keywords.any? { |keyword| tag["name"].match_keyword(keyword, match_options) } }
      end
    end

    # Remove nil and false values from the tags array
    tags.delete_if { |tag| !tag }

    raise NoResults, "No matching tags found" if tags.nil? || tags.empty?

    # Format tags with counts if the counts option is enabled
    if options[:count]
      tags.map! { |tag| "#{tag["name"]} (#{tag["count"]})" }
    else
      tags.map! { |tag| tag["name"] }
    end

    # Output the formatted tags
    @util.output_tags(tags, { :format => options[:format] })
  end
end

desc "List posts with tag(s)"
arg_name "tags", :multiple
command :posts_tagged do |c|
  c.desc "Boolean operator for multiple tags (AND/OR/NOT)"
  c.arg_name "bool"
  c.default_value "OR"
  c.flag %i[b bool], :must_match => /(AND|OR|NOT)/i, :type => String

  c.desc "Format to use when outputting file list: list, json, plist, csv or yaml. Defaults to list."
  c.arg_name "output_format"
  c.default_value "list"
  c.flag %i[f format], :must_match => /^(csv|list|yaml|json|plist)$/, :type => String

  c.desc "If output format is list, print without newlines."
  c.switch [:print0]

  c.action do |global_options, options, args|
    # Convert the boolean operator to uppercase for consistency
    bool = options[:bool].upcase

    # Initialize arrays to store files, tags, and matches
    files = []
    tags = []
    matches = []

    # Separate files and tags from the arguments
    args.length.times do
      arg = args.pop
      if File.exist?(arg)
        files.push(arg)  # Add existing files to the files array
      else
        tags.push(arg)  # Add non-file arguments to the tags array
      end
    end

    # If piped content is provided and it is a list of files, add them to the files array
    files.concat(@piped_content.split(global_options[:null] ? "\x00" : "\n")) if @piped_content && @piped_content.file_list?(global_options[:null])

    # If no files are provided, use the default post location
    if files.empty?
      if @jt.default_post_location && File.exist?(@jt.default_post_location)
        # Retrieves a list of files from the default post location with the specified post extension.
        # The files are located using a glob pattern that matches all files with the given extension.
        files = Dir.glob(File.join(@jt.default_post_location, "*.#{@jt.post_extension}"))
      end
    end

    # Exit if no valid filenames are found in the arguments
    raise NoValidFile if files.empty?

    # Iterate over each file to find matches based on the boolean operator
    files.each do |file|
      if File.exist?(file)
        post_tags = @jt.post_tags(file)  # Get tags for the current file

        if bool == "AND"
          # Check if all tags are present in the post tags
          matched = 0
          tags.each { |tag| matched += 1 if post_tags.include?(tag) }
          matches.push(file) if matched == tags.length
        elsif bool == "NOT"
          # Check if none of the tags are present in the post tags
          matched = false
          tags.each { |tag| matched = true if post_tags.include?(tag) }
          matches.push(file) unless matched
        else
          # Default to OR: Check if any of the tags are present in the post tags
          tags.each { |tag| matches.push(file) unless matches.include?(file) if post_tags.include?(tag) }
        end
      else
        # Exit if the file is not found
        raise FileNotFound, "File not found: #{file}"
      end
    end

    # Create a search string from the tags and boolean operator
    search_string = tags.join(" #{bool} ")

    # Output the results
    if matches.empty?
      @util.console_log "No matching files found for #{search_string}"
    else
      @util.console_log "(#{search_string})", { err: true }
      @util.output_tags(matches, { format: options[:format], print0: options[:print0], grouping: "files" })
    end
  end
end

desc "Show tags with fewer than X posts attached to them, optionally removing them from specified posts"
arg_name "file_pattern", :multiple
command :loners do |c|
  c.desc "Format to use when outputting tags to console: list, json, plist, csv or yaml. Defaults to yaml."
  c.arg_name "output_format"
  c.default_value "yaml"
  c.flag %i[f format], :must_match => /^(csv|list|yaml|json|plist)$/, :type => String

  c.desc "Upper limit for how many posts a tag can be attached to and still be a loner"
  c.arg_name "max"
  c.default_value "2"
  c.flag %i[m max], :default_value => 2, :must_match => /^\d+$/

  c.desc "Remove tags with fewer than X posts attached"
  c.switch %i[r remove], :default_value => false

  c.desc "Display output without attached occurence counts"
  c.switch [:no_counts], :default_value => false

  c.desc "Output a file list of tags that can be edited and passed back in for removing"
  c.arg_name "filename"
  c.flag %i[e edit], :default_value => false, :type => String

  c.action do |global_options, options, args|
    # Convert the max option to an integer
    max = options[:m].to_i

    # Initialize arrays to store files and keywords
    files = []
    keywords = []

    # Separate files and keywords from the arguments
    args.length.times do
      arg = args.pop
      if File.exist?(arg)
        files.push(arg)  # Add existing files to the files array
      else
        keywords.push(arg)  # Add non-file arguments to the keywords array
      end
    end

    # If piped content is provided and it is a list of files, add them to the files array
    files.concat(@piped_content.split(global_options[:null] ? "\x00" : "\n")) if @piped_content && @piped_content.file_list?(global_options[:null])

    # If no files are provided, use the default post location
    if files.empty?
      if @jt.default_post_location && File.exist?(@jt.default_post_location)
        files = Dir.glob(File.join(@jt.default_post_location, "*.#{@jt.post_extension}"))
      end
    end

    # Get tags with counts for the specified files
    loner_tags = @jt.tags({ :counts => true, :files => files })

    # Remove tags that are not loners (i.e., tags with counts greater than max)
    loner_tags.delete_if { |tag|
      tag.class == FalseClass || tag["count"] > max
    }

    # Sort loner tags by count
    loner_tags.sort_by! { |tag| tag["count"] }

    # Exit if no tags matched the criteria
    exit_now! "No tags matched the criteria" if loner_tags.empty? || loner_tags.nil?

    # If the edit option is provided, write the loner tags to a file for editing
    if options[:e]
      path = File.expand_path(options[:e])
      while File.exist?(path)
        if path =~ /(\d+)(\.[^\.]+?)?$/
          path.sub!(/(\d+)(\.[^\.]+?)?$/) do |m|
            $1.next! + $2
          end
        else
          path.sub!(/(\.[^\.]+?)?$/, '01\1')
        end
      end
      File.open(path, "w+") do |f|
        f.puts "# Edit this file to remove tags you want to keep,"
        f.puts "# then run `jtag remove -p '#{path}' [/path/to/posts/*.md]`"
        f.puts "# to remove any tags left in this file."
        f.puts "#"
        f.puts "# The post counts are included for your convenience, and will"
        f.puts "# be automatically ignored when reading the list back in."
        f.puts "#"
        f.puts "# Lines beginning with a # are comments (ignored), but you probably figured that out."
        loner_tags.each { |t|
          f.printf "% 3d |\t%s\n", t["count"], t["name"]
        }
      end

      @util.console_log "A list of results and instructions for use have been written to #{path}."
      if ENV["EDITOR"]
        @util.console_log
        print "Would you like to open the file in #{ENV["EDITOR"]} now? (y/N) "
        input = STDIN.gets
        if input =~ /^y/i
          system "#{ENV["EDITOR"]} '#{path}'"
        end
      end

      # If the remove option is provided, remove the loner tags from the specified files
    elsif options[:r]
      files = []
      args.length.times do
        arg = args.pop
        files.push(arg) if File.exist?(arg)
      end

      files.concat(@piped_content.split(global_options[:null] ? "\x00" : "\n")) if @piped_content && @piped_content.file_list?(global_options[:null])

      if files.empty?
        if @jt.default_post_location && File.exist?(@jt.default_post_location)
          files = Dir.glob(File.join(@jt.default_post_location, "*.#{@jt.post_extension}"))
        end
      end
      exit_now! "No valid filename in arguments" if files.empty?

      files.each { |file|
        tags = @jt.post_tags(file)
        loner_tags.each { |d|
          tags.delete_if { |tag|
            if global_options[:i]
              tag.downcase == d.downcase
            else
              tag == d
            end
          }
        }
        unless global_options[:t]
          @jt.update_file_tags(file, tags)
          @util.console_log "Updated tags for #{file}", :log => true, level: :warn
        end

        @util.console_log level: :info
        @util.console_log File.basename(file) + ":", level: :info
        @util.output_tags(tags, :format => options[:format], :filename => file)
      }

      # Otherwise, output the loner tags
    else
      @util.output_tags(loner_tags.map { |tag|
        count = options[:no_counts] ? "" : " (#{tag["count"]})"
        "#{tag["name"]}#{count}"
      }, :format => options[:format])
    end
  end
end

desc "Show the current tags for posts"
arg_name "file_pattern", :multiple
command :tags do |c|
  c.desc "Format to use when outputting tags to console: list, json, plist, csv or yaml. Defaults to yaml."
  c.arg_name "output_format"
  c.default_value "yaml"
  c.flag %i[f format], :must_match => /^(csv|list|yaml|json|plist)$/, :type => String

  c.action do |global_options, options, args|
    files = []
    args.length.times do
      arg = args.pop
      if File.exist?(arg)
        files.push(arg)
      end
    end

    files.concat(@piped_content.split(global_options[:null] ? "\x00" : "\n")) if @piped_content && @piped_content.file_list?(global_options[:null])

    tags = []
    files.each do |file|
      tags.concat(@jt.post_tags(file)) if File.exist?(file)

      if args.length > 0
        @util.console_log level: :info
        @util.console_log "STDIN:", level: :info
      end
    end

    if tags.empty? || tags.nil?
      @util.console_log "No tags in post", err: true, level: :info
    else
      tags.sort!
      tags.uniq!
      @util.output_tags(tags, { :format => options[:format] })
    end
  end
end

desc "Sort the existing tags for posts"
arg_name "file_pattern", :multiple
command :sort do |c|
  c.desc "Format to use when outputting tags to console: list, json, plist, csv or yaml. Defaults to yaml."
  c.arg_name "output_format"
  c.default_value "yaml"
  c.flag %i[f format], :must_match => /^(csv|list|yaml|json|plist)$/, :type => String

  c.action do |global_options, options, args|
    files = []
    args.length.times do
      arg = args.pop
      if File.exist?(arg)
        files.push(arg)
      end
    end

    files.concat(@piped_content.split(global_options[:null] ? "\x00" : "\n")) if @piped_content && @piped_content.file_list?(global_options[:null])

    files.each do |file|
      tags = @jt.post_tags(file)
      tags.uniq!
      tags.sort!
      unless global_options[:t]
        @jt.update_file_tags(file, tags)
      end
      @util.console_log level: :info
      @util.console_log "#{File.basename(file)}:", level: :info

      if tags.empty? || tags.nil?
        @util.console_log "No tags in post", err: true, level: :info
      else
        @util.output_tags(tags, { :format => options[:format], :filename => file })
      end
    end
  end
end

desc "Merge multiple tags into one"
long_desc "Scans the specified posts for any of the tags, merging any found into the last one in the list"
arg_name "tags to merge merge_tag"
command :merge do |c|
  c.desc "Format to use when outputting tags to console: list, json, plist, csv or yaml. Defaults to yaml."
  c.arg_name "output_format"
  c.default_value "yaml"
  c.flag %i[f format], :must_match => /^(csv|list|yaml|json|plist)$/, :type => String

  c.action do |global_options, options, args|
    files = []
    tags = []
    args.length.times do
      arg = args.pop
      if File.exist?(arg)
        files.push(arg)
      else
        tags.push(arg)
      end
    end

    files.concat(@piped_content.split(global_options[:null] ? "\x00" : "\n")) if @piped_content && @piped_content.file_list?(global_options[:null])

    if files.empty?
      if @jt.default_post_location && File.exist?(@jt.default_post_location)
        files = Dir.glob(File.join(@jt.default_post_location, "*.#{@jt.post_extension}"))
      end
    end
    exit_now! "No valid filename in arguments" if files.empty?
    exit_now! "Needs at least two tag inputs, one or more to merge, one to merge to" if tags.length < 2
    tags.reverse!
    merge_tag = tags.pop
    @util.console_log %(Merging #{tags.join(", ")} to #{merge_tag}), level: :info
    files.each do |file|
      new_tags = @jt.merge_tags(tags, merge_tag, file)
      next unless new_tags
      unless global_options[:test]
        @jt.update_file_tags(file, new_tags)
        @util.console_log level: :info
        @util.console_log "Updated tags for #{file}", log: true, level: :warn
      end

      @util.console_log level: :info
      @util.console_log "#{File.basename(file)}:", level: :info
      @util.output_tags(new_tags, { format: options[:format], filename: file })
    end
  end
end

desc "Blacklist a specific tag"
arg_name "tag [tag2...]"
command :blacklist do |c|
  c.desc "Remove (unblacklist) the arguments"
  c.switch [:r, "remove"]

  c.action do |global_options, options, args|
    if options[:r]
      @jt.unblacklist(args)
      @util.console_log "Removed #{args.join(", ")} from blacklist.", level: :info, err: true
    else
      @jt.blacklist(args)
      @util.console_log "Blacklisted #{args.join(", ")}.", level: :info, err: true
    end
  end
end

desc "Add tags to post(s)"
arg_name "tags... file(s)", :multiple
command :add do |c|
  c.desc "Format to use when outputting tags to console: list, json, plist, csv or yaml. Defaults to yaml."
  c.arg_name "output_format"
  c.default_value "yaml"
  c.flag %i[f format], :must_match => /^(csv|list|yaml|json|plist)$/, :type => String

  c.action do |global_options, options, args|
    files = []
    new_tags = []
    args.length.times do
      arg = args.pop
      if File.exist?(arg)
        files.push(arg)
      else
        new_tags.push(arg)
      end
    end

    files.concat(@piped_content.split(global_options[:null] ? "\x00" : "\n")) if @piped_content && @piped_content.file_list?(global_options[:null])

    if files.empty?
      if @jt.default_post_location && File.exist?(@jt.default_post_location)
        files = Dir.glob(File.join(@jt.default_post_location, "*.#{@jt.post_extension}"))
      end
    end
    raise NoValidFile if files.empty?
    raise NoTagsFound if new_tags.empty?

    files.each { |file|
      tags = @jt.post_tags(file)
      tags.concat(new_tags)
      tags.uniq!
      tags.sort!
      unless global_options[:t]
        @jt.update_file_tags(file, tags)
        @util.console_log "Updated tags for #{file}", log: true, level: :warn
      end

      @util.console_log level: :info
      @util.console_log "#{File.basename(file)}:", level: :info
      @util.output_tags(tags, :format => options[:format], :filename => file)
    }
  end
end

desc "Remove tags from post(s)"
arg_name "tags", :multiple
command :remove do |c|
  c.desc "Format to use when outputting tags to console: list, json, plist, csv or yaml. Defaults to yaml."
  c.arg_name "output_format"
  c.default_value "yaml"
  c.flag %i[f format], :must_match => /^(csv|list|yaml|json|plist)$/, :type => String

  c.desc "A filepath to a list of tags to be removed"
  c.long_desc "One tag per line, and leading numbers and pipes (|) will be ignored. This file format is generated automatically by the `loners` command, but any text file will do the trick."
  c.arg_name "input_file"
  c.flag %i[p path], :type => String

  c.action do |global_options, options, args|
    files = []
    remove_tags = []
    args.length.times do
      arg = args.pop
      if File.exist?(arg)
        files.push(arg)
      else
        remove_tags.push(arg) unless options[:p]
      end
    end

    files.concat(@piped_content.split(global_options[:null] ? "\x00" : "\n")) if @piped_content && @piped_content.file_list?(global_options[:null])

    if files.empty?
      if @jt.default_post_location && File.exist?(@jt.default_post_location)
        files = Dir.glob(File.join(@jt.default_post_location, "*.#{@jt.post_extension}"))
      end
    end
    exit_now! "No valid filename in arguments" if files.empty?

    if options[:p]
      path = File.expand_path(options[:p])
      exit_now! "Input file does not appear to be where you think it is." unless File.exist?(path)
      IO.read(path).each_line { |l|
        next if l =~ /^\s*#/
        if l =~ /^(?:[\s\d])*(?:\|\s*)?(\S.*?)$/
          remove_tags.push($1.strip)
        end
      }
      @util.console_log "Found #{remove_tags.length} tags in #{File.basename(path)}...", level: :info, err: true
    end

    raise NoTagsFound if remove_tags.empty?

    files.each { |file|
      tags = @jt.post_tags(file)
      remove_tags.each { |d|
        tags.delete_if { |tag|
          if global_options[:i]
            tag.downcase == d.downcase
          else
            tag == d
          end
        }
      }
      unless global_options[:t]
        @jt.update_file_tags(file, tags)
        @util.console_log "Updated tags for #{file}", log: true, level: :warn, err: true
      end

      @util.console_log level: :info
      @util.console_log "#{File.basename(file)}:", level: :info
      @util.output_tags(tags, { :format => options[:format], :filename => file })
    }
  end
end

desc "Generate a list of recommended tags, updating the file (unless dry run)"
arg_name "file_pattern", :multiple
command :tag do |c|
  c.desc 'Format to use when outputting tags to console: list, json, plist, csv or yaml. Use "complete" to output full text when input is STDIN.'
  c.arg_name "output_format"
  c.flag %i[f format], :must_match => /^(csv|list|yaml|json|plist|complete)$/, :type => String, :default_value => "yaml"

  c.action do |global_options, options, args|
    if @piped_content && !@piped_content.file_list?(global_options[:null])
      suggestions = @jt.suggest(@piped_content)
      if args.length > 0
        @util.console_log level: :info
        @util.console_log "STDIN:", level: info, err: true
      end

      @util.output_tags(suggestions, :format => options[:format], :filename => nil)
    end

    files = []
    args.length.times do
      arg = args.pop
      files.push(arg) if File.exist?(arg)
    end

    files.concat(@piped_content.split(global_options[:null] ? "\x00" : "\n")) if @piped_content && @piped_content.file_list?(global_options[:null])

    files.each do |file|
      if File.exist?(File.expand_path(file))
        input = IO.read(File.expand_path(file))
        suggestions = @jt.suggest(input)

        unless global_options[:t]
          if @jt.update_file_tags(file, suggestions)
            @util.console_log level: :info
            @util.console_log "Updated file #{file} with:", log: true, level: :warn
          else
            @util.console_log level: :info
            @util.console_log "Failed to update #{file} with:", log: true, level: :error
          end
        end
        if !global_options[:s] || global_options[:t]
          if args.length > 1
            @util.console_log level: :info
            @util.console_log "#{File.basename(file)}:", err: true, level: :info
          end
          @util.output_tags(suggestions, :format => options[:format], :filename => file)
        end
        suggestions = nil
      else
        raise FileNotFound, "No such file: #{file}"
      end
    end
  end
end

##
## Move deprecated config files to new location
##
## @return [void]
##
def update_deprecated_config
  if File.exist?(File.expand_path("~/.jtag"))
    FileUtils.mv(File.expand_path("~/.jtag"), File.expand_path("~/.config/jtag"))
    @util.console_log "Moved ~/.jtag to ~/.config/jtag", level: :info, err: true, log: false
  end
end

## TODO: Add a feature for converting YAML tags to OpenMeta or Mavericks tags
# desc 'Describe omtag here'
# arg_name 'Describe arguments to omtag here'
# command :omtag do |c|
#   c.action do |global_options,options,args|
##   system %Q{openmeta -a "#{@auto_tags.uniq.join('" "')}" -p "#{@update_file}"}
#     puts "omtag command ran"
#   end
# end

pre do |global, command, options, args|
  Signal.trap("PIPE", "EXIT")

  @util = JekyllTag::Util.new
  @util.config_target = if global[:config_dir]
      File.expand_path(global[:config_dir])
    else
      File.expand_path("~/.config/jtag")
    end

  # if global[:debug] == 0 or global[:silent], run silently
  @util.silent = global[:debug] == 0 || global[:silent]

  # set up logging
  logfile = File.open(File.join(Dir.tmpdir, "jtag_actions.log"), "a")

  # set up logger
  @util.log = Logger.new(logfile, shift_age = 7, shift_size = 1048576)

  # set log level based on flags
  @util.debug_level = @silent ? 0 : global[:debug]

  # check for config files, write them if they don't exist
  unless @util.config_files_complete?
    @util.write_config
    @util.console_log "Missing config files written to #{@util.config_target}. Please check your configuration.", err: true, level: :error
    return false
  end

  configfile = File.join(@util.config_target, "config.yml")

  # load config file
  config = YAML.load_file(configfile)
  global[:config] = config.symbolize_keys

  @piped_content = $stdin.read if $stdin.fcntl(Fcntl::F_GETFL, 0) == 0 || $stdin.stat.pipe?

  @jt = JekyllTag::JTag.new(@util.config_target, global[:config])

  true
end

post do |global, command, options, args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  if exception.is_a?(NoValidFile) || exception.is_a?(FileNotFound) || exception.is_a?(NoTagsFound)
    @util.console_log "#{@jt.color(:red)}#{exception.message}", err: true, level: :error
    return false
  end

  # return false to skip default error handling
  true
end

exit run(ARGV)
